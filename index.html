<!DOCTYPE html>
<html>
	<head>

		<!-- title -->
		<title>Sudoku Solver</title>

		<!-- charset -->
		<meta charset="UTF-8">

		<!-- icon for IOS shortcut -->
		<link rel="apple-touch-icon" href="./apple-touch-icon.png">

		<!-- disable zoom on mobile devices -->
		<link rel="icon" href="./favicon.ico">

		<!-- disable zoom on mobile devices -->
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

    <script type="text/javascript">

			var STATUS = {};

			function setStatus(name, value){
				STATUS[name] = value;
			}
			function getStatus(name){
				return STATUS[name];
			}
			function clearStatus(){
				STATUS = {};
			}

      function validateNumber() {
					var key = window.event ? event.keyCode : event.which;
          if (event.keyCode == 8 || event.keyCode == 46 || event.keyCode == 32) {
              return true;
          } else if (key < 49 || key > 57) {
              return false;
          } else {
              return true;
          }
      };

      function checkBlockValid(values){

        for(let i = 0; i < 9; i++){

          let numbers = [];

          for(let j = 0; j < 9; j++){

            let number = values[j + 9*i][0];

            if(number != 0){
              if(numbers.indexOf(number) == -1){
                numbers.push(number);
              }else{
                return false;
              }
            }
          }
        }

        return true;

      }

      function checkRowValid(values){

        /*
        0 1 2    9  10 11   18 19 20
        3 4 5    12 13 14   21 22 23
        6 7 8    15 16 17   24 25 26

        27 28 29   36 37 38   45 46 47
        30 31 32   39 40 41   48 49 50
        33 34 35   42 43 44   51 52 53


        54 55 56   63 64 65   72 73 74
        57 58 59   66 67 68   75 76 77
        60 61 62   69 70 71   78 79 80
        */

        let rows = [
          [values[0],values[1],values[2],values[9],values[10],values[11],values[18],values[19],values[20]],
          [values[3],values[4],values[5],values[12],values[13],values[14],values[21],values[22],values[23]],
          [values[6],values[7],values[8],values[15],values[16],values[17],values[24],values[25],values[26]],
          [values[27],values[28],values[29],values[36],values[37],values[38],values[45],values[46],values[47]],
          [values[30],values[31],values[32],values[39],values[40],values[41],values[48],values[49],values[50]],
          [values[33],values[34],values[35],values[42],values[43],values[44],values[51],values[52],values[53]],
          [values[54],values[55],values[56],values[63],values[64],values[65],values[72],values[73],values[74]],
          [values[57],values[58],values[59],values[66],values[67],values[68],values[75],values[76],values[77]],
          [values[60],values[61],values[62],values[69],values[70],values[71],values[78],values[79],values[80]]
        ];


        for(let i = 0; i < 9; i++){

          let numbers = [];

          for(let j = 0; j < 9; j++){

            let number = rows[i][j][0];

            if(number != 0){
              if(numbers.indexOf(number) == -1){
                numbers.push(number);
              }else{
                return false;
              }
            }
          }
        }

        return true;

      }

      function checkColumnValid(values){

        /*
        0 1 2    9  10 11   18 19 20
        3 4 5    12 13 14   21 22 23
        6 7 8    15 16 17   24 25 26

        27 28 29   36 37 38   45 46 47
        30 31 32   39 40 41   48 49 50
        33 34 35   42 43 44   51 52 53


        54 55 56   63 64 65   72 73 74
        57 58 59   66 67 68   75 76 77
        60 61 62   69 70 71   78 79 80
        */

        let columns = [
          [values[0],values[3],values[6],values[27],values[30],values[33],values[54],values[57],values[60]],
          [values[1],values[4],values[7],values[28],values[31],values[34],values[55],values[58],values[61]],
          [values[2],values[5],values[8],values[29],values[32],values[35],values[56],values[59],values[62]],

          [values[9],values[12],values[15],values[36],values[39],values[42],values[63],values[66],values[69]],
          [values[10],values[13],values[16],values[37],values[40],values[43],values[64],values[67],values[70]],
          [values[11],values[14],values[17],values[38],values[41],values[44],values[65],values[68],values[71]],

          [values[18],values[21],values[24],values[45],values[48],values[51],values[72],values[75],values[78]],
          [values[19],values[22],values[25],values[46],values[49],values[52],values[73],values[76],values[79]],
          [values[20],values[23],values[26],values[47],values[50],values[53],values[74],values[77],values[80]]
        ];


        for(let i = 0; i < 9; i++){

          let numbers = [];

          for(let j = 0; j < 9; j++){

            let number = columns[i][j][0];

            if(number != 0){
              if(numbers.indexOf(number) == -1){
                numbers.push(number);
              }else{
                return false;
              }
            }
          }
        }

        return true;

      }

      // each 9 elements, we have a new block
      function sudokuIsValid(values){

        let block_valid = checkBlockValid(values);

        let column_valid = checkColumnValid(values);

        let row_valid = checkRowValid(values);

        return block_valid && column_valid && row_valid;
      }

      function getSudokuValues(){

        let elements = document.getElementsByClassName("sudoku-cell-inner");
        let values = [];
        for(let i = 0; i < elements.length; i++){
          let v = elements[i].value;
					values.push([v.length > 0 ? +v : 0, elements[i]]);
        }

				let f = document.getElementById("last_input");
				let f_ = f.value;
				values.push([f_.length > 0 ? + f_ : 0, f]);

        return values;
      }

      function getFirstZeroIndex(values){
        for(let i = 0; i < values.length; i++){
          if(values[i][0] == 0){
            return i;
          }
        }

        return -1;
      }

      function stepUp(values){

        let first_zero_index = getFirstZeroIndex(values);

        if(first_zero_index == -1){
          sudoku_solution_found();
          return 1;
        }

        values[first_zero_index][1].value = 1;
        return 0;
      }

      function sudoku_solution_found(){
        mark_green_cells();
      }

      function sudoku_has_no_solution(){
        mark_red_starters();
      }

      function getStepBackIndex(current_index, values){

        current_index = current_index - 1;

        if(current_index < 0){
          return -1;
        }

        while(values[current_index][1].name == "locked"){

          current_index = current_index - 1;

          if(current_index < 0){
            return -1;
          }
        }

        return current_index;
      }

      function backStep(values){

        let first_zero_index = getFirstZeroIndex(values);

        let first_before_first_zero_index = getStepBackIndex(first_zero_index, values);

        if(first_before_first_zero_index < 0){
          sudoku_has_no_solution();
          return 2;
        }

        while(values[first_before_first_zero_index][0] == 9){

          values[first_before_first_zero_index][0] = 0;
          values[first_before_first_zero_index][1].value = "";

          first_zero_index = getFirstZeroIndex(values);

          first_before_first_zero_index = getStepBackIndex(first_zero_index, values);

          if(first_before_first_zero_index < 0){
            sudoku_has_no_solution();
            return 2;
          }
        }

        values[first_before_first_zero_index][1].value = values[first_before_first_zero_index][0] + 1;

        return 0;
      }

      function solve_inner(){

        let res = 0;

        while(res == 0){
          let v = getSudokuValues();

          if(sudokuIsValid(v)){
            res = stepUp(v);
          }else{
            res = backStep(v);
          }
        }
      }

      function lock_sudoku_start(){

        let v = getSudokuValues();

        for(let i = 0; i < v.length; i++){

          v[i][1].disabled = true;

					if(v[i][1].name == "reset_me_on_solver"){
						v[i][0] = 0;
						v[i][1].value = "";
					}

          if(v[i][0] != 0){
            v[i][1].name = "locked";
            v[i][1].style.backgroundColor = "rgb(222, 222, 222)";
          }else{
            v[i][1].name = "";
            v[i][1].style.backgroundColor = "";
          }
        }

      }

      function mark_green_cells(){
        let v = getSudokuValues();
        for(let i = 0; i < v.length; i++){

					v[i][1].disabled = true;

          v[i][1].style.backgroundColor = "rgba(158, 226, 163,0.1)";
          v[i][1].style.color = "";

          if(v[i][1].name == "locked"){
            v[i][1].style.backgroundColor = "rgba(158, 251, 165, 0.8)";
          }
        }
      }

      function mark_red_starters(){
        let v = getSudokuValues();
        for(let i = 0; i < v.length; i++){
          if(v[i][1].name == "locked"){
            v[i][1].style.backgroundColor = "rgb(226, 158, 158)";
            v[i][1].style.color = "";
          }
        }
      }

			function getRandomInteger(min, max) {
			    return Math.floor(Math.random() * (max - min) + min);
			}

			function getRandomSudokuCell(){

				let limit = 40;

				let rand = getRandomInteger(0,limit);

				let res = rand - (limit-10);

				if(res <= 0){ res = "";}

				return res;
			}

			function newSudoku(){

				clearSudoku();

				let seen_vector = [];
				let v = getSudokuValues();
				for(let i = 0; i < v.length; i++){
					let res = getRandomSudokuCell();
					if(seen_vector.indexOf(res) == -1){
						v[i][1].value = res;
						seen_vector.push(res);
					}
				}

				solve();

				if(!sudokuIsValid(getSudokuValues())){
					newSudoku();
				}
			}

			function countElementsInList(list, element){
				let c = 0;
				for(let i = 0; i < list.length; i++){
					if(list[i] == element){
						c++;
					}
				}
				return c;
			}

			function testAllNumbers(distribution){
				let domain = ["1","2","3","4","5","6","7","8","9"];
				for(let i = 0; i < domain.length; i++){
					console.log(domain[i], countElementsInList(distribution, domain[i]));
				}
			}

			function similarDistribution(amount){

				let domain = ["1","2","3","4","5","6","7","8","9"];

				let distribution = ["1","2","3","4","5","6","7","8","9","1","2","3","4","5","6","7","8","9"];

				let max_same = 5;

				while(distribution.length < amount && domain.length > 0){

					let picked = getRandomInteger(0, domain.length);

					let current_amount = getRandomInteger(1, Math.min(amount - distribution.length,max_same));

					let element = domain[picked];

					for(let i = 0; i < current_amount; i++){
						distribution.push(element);

						if(countElementsInList(distribution, element) >= max_same){
						  domain.splice(domain.indexOf(element), 1);

							while(countElementsInList(distribution, element) > max_same){
								distribution.splice(distribution.indexOf(element), 1);
							}

							break;
						}
					}
				}
				return distribution;
			}

			function generate(){

				let visibles = +document.getElementById("select_for_cells").value;
				let similarity = document.getElementById("select_for_spread").value;
				let table = document.getElementById("main_table");

				table.style.display = "none";
				newSudoku();

				let known_solution = getSudokuValues();

				clearSudoku();
				table.style.display = "";

				toggleHelpButton(true);

				startTimer();

				setStatus("solution", solutionToJson(known_solution));

				localStorage.setItem("saved_solution", JSON.stringify(solutionToJson(known_solution)));

				let v = getSudokuValues();
				let stop = false;

				let similarDistributionVector = similarDistribution(visibles);

				while(!stop){

					for(let i = 0; i < v.length - 1; i++){

						if(v[i][1].name != "locked"){

							let test_passed = false;

							if(similarity=="Random"){
								let res = getRandomInteger(0,100);
								test_passed = res > 90;
							}

							if(similarity=="Similar"){
								if(known_solution[i][0] == similarDistributionVector[0]){
									similarDistributionVector.shift();
									test_passed = true;
								}
							}

							if(test_passed){
								v[i][1].disabled = true;
								v[i][1].name = "locked";
								v[i][1].style.backgroundColor = "rgb(222, 222, 222)";
								v[i][1].value = known_solution[i][0];
								visibles = visibles - 1;
							}

							if(visibles <= 0){
								stop = true;
								break;
							}
						}
					}
				}

				markCellsAsNonStartes();

				saveCurrentSudoku();

				setStatus("help_requested",0);
			}

			function markCellsAsNonStartes() {
				let v = getSudokuValues();
				for(let i = 0; i < v.length; i++){
					if(!v[i][1].disabled){
						v[i][1].name = "reset_me_on_solver";
					}
				}
			}

			function clearDraftBlocks(){
				let v = document.getElementsByClassName("sudoku-cell-inner-pencil");
				for(let i = 0; i < v.length; i++){
						v[i].value = "";
				}
			}

      function clearSudoku(){

				colorLimitedNumbers([0,0,0,0,0,0,0,0,0]);

				clearAllStoreds();

				closeTimer();

				toggleHelpButton(false);

				evidenceSameNumbers("");

				clearDraftBlocks();

				setStatus("solution", null);

				setStatus("can_solve", true);

        let v = getSudokuValues();

        for(let i = 0; i < v.length; i++){

          v[i][1].disabled = false;
          v[i][1].value = "";
          v[i][1].name = "";
          v[i][1].style.backgroundColor = "";
          v[i][1].style.color = "";
        }
      }


			function buttonSolve(){

				let free = getStatus("can_solve") != false;
				if(free){
					closeTimer();
					evidenceSameNumbers("");
					solve();
					setStatus("can_solve", false);
				}
			}

      function solve(){

				document.getElementById("last_input").value = "";

        lock_sudoku_start();

        solve_inner();
      }

			function colorLimitedNumbers(counter){

				let numbers = document.getElementsByClassName("numeber_list_el");

				localStorage.setItem("saved_compl_numbers", JSON.stringify(counter));

				for(let i = 0; i < numbers.length; i++){
					if(counter[i] == 9){
						numbers[i].style.opacity = "1";
					}else{
						numbers[i].style.opacity = "0.2";
					}
				}
			}

			function sudokuIsOver(){

				let values = getSudokuValues();

				let result = true;

				let counter = [0,0,0,0,0,0,0,0,0];

				for(let i = 0; i < values.length-1; i++){
					if(values[i][0] == 0){
						result = false;
					}else{
						counter[values[i][0]-1] += 1;
					}
				}

				colorLimitedNumbers(counter);

				if(!result){
					return false;
				}

				return sudokuIsValid(values);
			}

			function save_current_win(){

				let name = prompt("You won! Insert a nick name to save this win.");

				let name_ = "-";

				if(name != undefined){
					if(name.length > 0){
						name_ = name;
					}
				}

				let date = new Date();

				let date_formatted = date.toDateString() + " " + date.toLocaleTimeString();

				let win = {
					date : date_formatted,
					helps : getStatus("help_requested"),
					difficulty: +document.getElementById("select_for_cells").value,
					diversity: document.getElementById("select_for_spread").value,
					name: name_
				};

				let wins = localStorage.getItem("sudoku_wins");
				if(wins != null){
					let vect = JSON.parse(wins);
					vect.push(win);
					localStorage.setItem("sudoku_wins", JSON.stringify(vect));

				}else{
					localStorage.setItem("sudoku_wins", JSON.stringify([win]));
				}
			}

			function checkSudokuIsComplete(){
				if(sudokuIsOver()){
					pauseTimer();
					mark_green_cells();
					save_current_win();
					return true;
				}

				return false;
			}

			function cellEdited(number){

				if(!checkSudokuIsComplete()){
					evidenceSameNumbers(number);
				}

				saveCurrentSudoku();
			}

			function saveCurrentSudoku(){
				let v = getSudokuValues();
				let stats = [];
				for(let i = 0; i < v.length-1; i++){
					stats.push({ "val": v[i][1].value, "name": v[i][1].name });
				}

				localStorage.setItem("saved_sudoku", JSON.stringify(stats));
			}

			function solutionToJson(v){
				let stats = [];
				for(let i = 0; i < v.length-1; i++){
					stats.push(v[i][0]);
				}
				return stats;
			}

			function clearAllStoreds(){
				localStorage.removeItem("saved_timer_count");
				localStorage.removeItem("saved_solution");
				localStorage.removeItem("saved_sudoku");
				localStorage.removeItem("saved_compl_numbers");
				localStorage.removeItem("saved_help_requested");
			}

			function loadStoredSudoku(){

				let helps = localStorage.getItem("saved_help_requested");
				if(helps != null){
					setStatus("help_requested",JSON.parse(helps));
				}

				let counters = localStorage.getItem("saved_compl_numbers");
				if(counters != null){
					colorLimitedNumbers(JSON.parse(counters));
				}

				let timer = localStorage.getItem("saved_timer_count");
				if(timer != null){
					setStatus("timer_count",JSON.parse(timer));
					setStatus("timer", setInterval(timerCallback,1000));
				}

				let sol = localStorage.getItem("saved_solution");
				if(sol != null){
					setStatus("solution", JSON.parse(sol));
					toggleHelpButton(true);
				}

				let values = localStorage.getItem("saved_sudoku");
				if(values != null){
					let parsed = JSON.parse(values);

					let v = getSudokuValues();

					for(let i = 0; i < parsed.length; i++){

						v[i][1].value = parsed[i]["val"];
						v[i][1].name = parsed[i]["name"];

						if(parsed[i]["name"] == "locked"){
							v[i][1].style.backgroundColor = "rgb(222, 222, 222)";
							v[i][1].disabled = true;
						}
					}
				}
			}

			function evidenceSameNumbers(number){

				let v = getSudokuValues();
				for(let i = 0; i < v.length; i++){

					if(v[i][0] == number && number != ""){
						if(v[i][1].name == "locked"){
							v[i][1].className += " evidence_locked";
						}else{
							v[i][1].className += " evidence";
						}
					}else{
						v[i][1].className = v[i][1].className.split(" ")[0];
					}
				}
			}

			function initTable(){

				let main_table = document.getElementById("main_table");

				let html_for_inner_row = '<td><div class="sudoku-cell">'+
																 '<input class="sudoku-cell-inner" type="text" maxlength="1" onfocus="cellEdited(this.value);" onkeyup="cellEdited(this.value);" onkeypress="return validateNumber();" inputmode="numeric">'+
																 '<input class="sudoku-cell-inner-pencil" maxlength="3" type="text"></div></td>';

				let html_for_open_inner = '<td>'+
																	'	<table class="inner_table">'+
																	'		<tr>';

				let html_for_closed_ineer = '			</tr>'+
																		'		</table>'+
																		'</td>';

				let html_for_inner_row_separator = "</tr><tr>";

				let html_for_inner_table = html_for_open_inner;
				for(let i = 0; i < 3; i++){
					html_for_inner_table += html_for_inner_row + html_for_inner_row + html_for_inner_row;
					if(i != 2){
						html_for_inner_table += html_for_inner_row_separator;
					}
				}
				html_for_inner_table += html_for_closed_ineer;

				let html_main_table_row = "<tr>" + html_for_inner_table + html_for_inner_table + html_for_inner_table + "</tr>";

				for(let i = 0; i < 3; i++){
					main_table.innerHTML += html_main_table_row;
				}
			}

			function initSelect(){

				let select = document.getElementById("select_for_cells");

				let index_def_choice = 1;

				let values = [["Few (20)",20], ["Normal (25)",25], ["Many (30)",30], ["Half full (40)",40]];

				for(let i = 0; i < values.length; i++){

					let opt = document.createElement("option");
					opt.value = values[i][1];
					opt.innerHTML = values[i][0];

					if(index_def_choice == 0){
						opt.selected = "true";
					}
					index_def_choice = index_def_choice - 1;

					select.appendChild(opt);
				}
			}

			function testSudoku(){

				let tb = document.getElementById("test_button");

				if(sudokuIsValid(getSudokuValues())){
					tb.style.backgroundColor = "rgb(106, 225, 76)";
					tb.innerHTML = "CORRECT!";
				}else{
					tb.style.backgroundColor = "rgb(225, 76, 76)";
					tb.innerHTML = "WRONG!";
				}

				tb.onclick = null;

				setTimeout(function(){
					let tb = document.getElementById("test_button");
					tb.style.backgroundColor = "";
					tb.innerHTML = "TEST CORRECTNESS";
					tb.onclick = testSudoku;
				}, 1500);
			}

			function setup(){

				initTable();

				initSelect();

				loadStoredSudoku();

				gotoPage(1);

				document.body.style.opacity = "1";
			}


			function showPaperMode(){

				let showDraft = getStatus("show_draft") != false;

				setStatus("show_draft", !showDraft);

				let cells = document.getElementsByClassName("sudoku-cell-inner-pencil");
				for(let i = 0; i < cells.length; i++){
					if(showDraft){
						cells[i].style.display = "block";
					}else{
						cells[i].style.display = "none";
					}
				}
			}

			function toggleHelpButton(toggle){

				let b = document.getElementById("help_button");
				if(toggle){
					b.style.opacity = "1";
					b.style.cursor = "pointer";
				}else{
					b.style.opacity = "0.3";
					b.style.cursor = "unset";
				}
			}

			function addOneNumber() {

				setStatus("help_requested",getStatus("help_requested")+1);
				localStorage.setItem("saved_help_requested", getStatus("help_requested"));

				let solution = getStatus("solution");

				let v = getSudokuValues();

				if(solution != undefined){

					let prob = 90;

					while(prob > 10){
						for(let i = 0; i < v.length; i++){
							if(getRandomInteger(0,100) > prob && v[i][1].name != "locked" ){
								v[i][1].value = solution[i];
								v[i][1].name = "locked";
								v[i][1].style.backgroundColor = "rgb(222, 222, 222)";
								v[i][1].disabled = true;

								saveCurrentSudoku();

								checkSudokuIsComplete();

								return;
							}
						}
						prob = prob - 10;
					}
				}
			}

			function closeTimer() {
				if(getStatus("timer") == undefined){
					return;
				}
				clearInterval(getStatus("timer"));
				document.getElementById("timer").style.opacity = "0";
			}

			function pauseTimer() {
				if(getStatus("timer") == undefined){
					return;
				}
				clearInterval(getStatus("timer"));

				let t = document.getElementById("timer").innerHTML;
				t = t.split("⏲")[1];

				document.getElementById("timer").innerHTML = "Sudoku completed in " + t;
				clearAllStoreds();
			}

			function startTimer() {
				setStatus("timer_count",0);
				localStorage.setItem("saved_timer_count", JSON.stringify(0));

				setStatus("timer", setInterval(timerCallback,1000));
			}

			function timerCallback(){
				let current = getStatus("timer_count") + 1;
				setStatus("timer_count",current);
				localStorage.setItem("saved_timer_count", JSON.stringify(current));

				let lbl = "⏲ " + toHHMMSS(current).toString();

				document.getElementById("timer").innerHTML = lbl;
				document.getElementById("timer").style.opacity = "1";
			}


			// https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
			function toHHMMSS(sec_num) {

			    var hours   = Math.floor(sec_num / 3600);
			    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
			    var seconds = sec_num - (hours * 3600) - (minutes * 60);

			    if (hours   < 10) {hours   = "0"+hours;}
			    if (minutes < 10) {minutes = "0"+minutes;}
			    if (seconds < 10) {seconds = "0"+seconds;}

			    return hours+':'+minutes+':'+seconds;
			}

			function gotoPage(n){
				for(let i = 0; i < 10; i++){
					let p = document.getElementById("page_" + i.toString());
					if(p != null){
						p.style.display = "none";
					}else{
					}
				}
				let curr = document.getElementById("page_" + n.toString());
				if(curr != null){
					curr.style.display = "block";
				}
			}

			function getHistoryVoice(label) {

				let l = document.createElement("div");
				l.className = "record_item";
				l.innerHTML = label;

				return l;
			}

			function init_win_history(){

				let wins = localStorage.getItem("sudoku_wins");

				let wrap = document.getElementById("wins_list");
				while(wrap.firstChild){
					wrap.removeChild(wrap.firstChild);
				}

				let inner_wrap = document.createElement("div");
				inner_wrap.className = "record_row_wrapper";
				wrap.appendChild(inner_wrap);

				let headers = ["Name", "Initial cells", "Diversity", "Used Helps", "Date"];

				let names = ["name", "difficulty", "diversity", "helps", "date"];

				if(wins != null){

					let row = document.createElement("div");
					row.className = "record_row";
					for(let j = 0; j < headers.length; j++){
						row.appendChild(getHistoryVoice(headers[j]));
						row.lastChild.style.fontWeight = "bold";
					}
					inner_wrap.appendChild(row);

					let vect = JSON.parse(wins);
					for(let i = 0; i < vect.length; i++){

						let w = vect[i];
						let row = document.createElement("div");
						row.className = "record_row";
						for(let j = 0; j < names.length; j++){
							row.appendChild(getHistoryVoice(w[names[j]]));
						}

						inner_wrap.appendChild(row);
					}
				}else{
					let no_items = document.createElement("div");
					no_items.innerHTML = "You have no win records yet.";
					no_items.className = "no_records";
					wrap.appendChild(no_items);
				}
			}

    </script>

		<style type="text/css">
					body{
						margin: 0;
						font-family: Arial;
    				padding-bottom: 1em;
						opacity: 0;
          }
					input:disabled{
						color: black;
						-webkit-text-fill-color: black;
						opacity: 1;
					}
					.record_row_wrapper{
						overflow: auto;
						margin: 1rem;
					}
					.record_row{
						padding: 0.2rem 1rem;
    				width: 45rem;
					}
					.record_item{
						display: inline-block;
				    opacity: 0.8;
				    margin: 0 2rem;
				    margin-left: 0;
				    min-width: 5rem;
				    font-size: 0.8rem;
					}
					.no_records{
						margin: 3rem;
    				opacity: 0.8;
					}
          .title{
            margin: 1rem;
            font-size: 1.4rem;
            font-weight: bold;
						margin-bottom: 0.4rem;
          }
          .sub-title{
            margin: 1rem;
            font-size: 0.8rem;
						max-width: 38rem;
						margin-top: 0;
          }
          .sudoku-cell{
						width: 6.5vw;
				    max-width: 2.5em;
				    padding: 2px;
          }
          .sudoku-cell-inner{
            text-align: center;
            width: 90%;
            line-height: 1.4em;
						font-weight: bold;
          }
					.sudoku-cell-inner-pencil{
						text-align: center;
				    width: 96%;
				    height: 1em;
				    line-height: 1.4em;
				    color: rgb(77, 77, 77);
				    background-color: rgb(244, 244, 244);
				    border: 0.1em solid rgb(162, 162, 162);
				    position: relative;
				    margin-top: -0.15em;
						display: none;
					}
          .sudoku-vert-sep{
            border-left: 0.4em solid black;
            height: 1.4em;
          }
          .button{
						border: 0.1rem solid rgba(0,0,0,0.3);
				    color: rgba(0,0,0,0.8);
				    border-radius: 0.5rem;
				    font-size: 0.7rem;
				    margin: 0 1rem;
				    width: 15rem;
				    text-align: center;
				    padding: 0.2rem;
				    cursor: pointer;
				    user-select: none;
				    line-height: 1rem;
				    display: inline-block;
				    margin-top: 0.9rem;
          }
          .button:hover{
            background-color: rgba(0,0,0,0.1);
          }
          .button:active{
            background-color: rgba(0,0,0,0.2);
          }
					.input_wrap{
						display: inline-block;
						margin: 0.5rem 1rem;
					}
					.select_hint{
						font-size: 0.8rem;
    				opacity: 0.8;
    				padding-bottom: 0.5rem;
					}
					.version{
						position: fixed;
						right: 1rem;
						bottom: 1rem;
						opacity: 0.3;
						font-size: 0.8rem;
					}
					.main_table{
						margin:1em;
						background-color: rgb(230, 230, 230);
				    margin-bottom: 0.5em;
					}
					.inner_table{
						border: 0.1em solid rgb(64, 64, 64);
				    margin: -0.1em -0.15em;
				    padding-right: 4px;
					}
					.options_wrapper{
				    padding: 0.5rem;
				    border: 0.1rem solid rgba(0,0,0,0.3);
				    border-radius: 0.5rem;
				    width: 14.3rem;
						display: inline-block;
						margin: 1rem 2rem;
					}
					.options_title{
						opacity: 0.8;
						font-size: 0.9rem;
					}
					.buttons_wrapper{
						display: inline-block;
						margin-left: 1rem;
					  margin-right: -2rem;
					}
					.new_sudoku_button{
						margin: 0.2rem;
						width: 13rem;
						margin-bottom: 1rem;
					}
					.evidence_locked{
    				background-color: rgb(136, 150, 254) !important;
					}
					.evidence{
						background-color: rgb(208, 218, 255);
					}
					.sudoku-time{
						font-size: 0.8rem;
						float: right;
						width: 4.5rem;
						margin-top: -0.2rem;
						opacity: 0.8;
					}
					.main_table_wrap{
						margin-bottom: 1rem;
					}
					.numbers_list_wrap{
						border: 0.1rem solid rgba(0,0,0,0.3);
				    border-radius: 0.5rem;
				    margin: 0px 2rem;
				    padding: 0.5rem;
				    width: 35vw;
				    max-width: 25rem;
				    min-width: 14.4rem;
					}
					.numeber_list_el{
						display: inline-block;
				    opacity: 0.2;
				    width: 9%;
				    text-align: center;
						user-select: none;
					}
					.numbers_list_title{
						font-size: 0.9rem;
						opacity: 0.8;
						margin-bottom: 0.4rem;
					}
					.options_main_wrap{

					}
					.tool_top_bar{
						border-bottom: 1px solid black;
					}
					.tool_top{
						display: inline-block;
				    padding: 0.3rem 1rem;
				    opacity: 0.8;
				    border-right: 1px solid black;
				    font-weight: bold;
				    font-size: 0.9rem;
				    cursor: pointer;
				    margin-left: -0.25rem;
						padding-top: 0.8rem;
					}
					.tool_top:hover{
						background-color: rgba(0,0,0,0.2);
					}
					.tool_top:active{
						background-color: rgba(0,0,0,0.4);
					}
					.page{
						display: none;
					}
					.rules{
						opacity: 0.8;
				    margin: 0 1rem;
				    font-size: 0.8rem;
					}
		</style>
	</head>

	<body onload="setup();">


			<div class="tool_top_bar" >
				<div class="tool_top" onclick="gotoPage(1);">Home</div>
				<div class="tool_top" onclick="gotoPage(2);init_win_history();">Win History</div>
				<div class="tool_top" onclick="gotoPage(3);">How to play</div>
			</div>


			<div id="page_1" class="page">
				<div class="title">Sudoku Solver</div>
				<div class="sub-title">
					<strong>Insert a sudoku scheme to solve, or generate a new one to play with.</strong>
					In case the page is left or reloaded the site will save automatically the sudoku session, but the draft data will be lost.
				</div>

				<div id="main_table_wrap" class="main_table_wrap">
	      	<table class="main_table" id="main_table"></table>
					<input style="display:none;" type="text" id="last_input">
				</div>

				<div class="options_main_wrap">
					<div class="numbers_list_wrap">
						<div class="numbers_list_title"><span>Numbers completed</span><span class="sudoku-time" style="opacity:0;" id="timer">⏲ - </span></div>
						<div class="numeber_list_el">1</div>
						<div class="numeber_list_el">2</div>
						<div class="numeber_list_el">3</div>
						<div class="numeber_list_el">4</div>
						<div class="numeber_list_el">5</div>
						<div class="numeber_list_el">6</div>
						<div class="numeber_list_el">7</div>
						<div class="numeber_list_el">8</div>
						<div class="numeber_list_el">9</div>
					</div>

					<div class="buttons_wrapper">
						<div class="button" onclick="showPaperMode();">&#9998; DRAFT MODE</div>
						<br>
						<div class="button" id="test_button" onclick="testSudoku();" style="transition: background-color 0.5s linear">TEST CORRECTNESS</div>
						<br>
						<div class="button" id="help_button" onclick="addOneNumber();" style="opacity:0.3; cursor:unset;">ADD ONE NUMBER</div>
						<br>
						<div class="button" id="solve_button" onclick="buttonSolve();">SOLVE SUDOKU</div>
						<br>
						<div class="button" id="clear_button" onclick="clearSudoku();">CLEAR</div>
					</div>

					<div class="options_wrapper">
						<div class="button new_sudoku_button" onclick="generate();">NEW SUDOKU</div>
						<br>
						<div class="options_title">New sudoku options</div>
						<div class="input_wrap">
							<div class="select_hint">Visible numbers:</div>
							<select id="select_for_cells" style="width:13rem; font-size:1rem; opacity: 0.8;"></select>
						</div>
						<div class="input_wrap">
							<div class="select_hint">Numbers variety:</div>
							<select id="select_for_spread" style="width:13rem; font-size:1rem; opacity: 0.8;">
								<option value="Similar">Similar (easier)</option>
								<option value="Random">Random (harder)</option>
							</select>
						</div>
					</div>
				</div>
			</div>

			<div id="page_2" class="page">
				<div class="title">Win History</div>
				<div class="sub-title">
					Here are listed your historical wins on the current web browser.
				</div>
				<div id="wins_list"></div>
			</div>

			<div id="page_3" class="page">
				<div class="title">How to play</div>
				<div class="sub-title">
					Here are the instructions to play a sudoku puzzle.
				</div>

				<div class="rules">

					The sudoku puzzle consists of a grid of 3x3 blocks, each block containing a grid of 3x3 cells, for a total of 81 cells.

					To solve the puzzle, one must fill each cell with a number without breaking the following constraints:
					<ul>
						<li>Each row cannot contain duplicated numbers</li>
						<li>Each column cannot contain duplicated numbers</li>
						<li>Each block cannot contain duplicated numbers</li>
					</ul>

					Or, in terms of objectives:
					<ul>
						<li>Each row must contain all numbers from 1 to 9</li>
						<li>Each column must contain all numbers from 1 to 9</li>
						<li>Each block must contain all numbers from 1 to 9</li>
					</ul>

				</div>
			</div>

			<div class="version">Version 1.8</div>
	</body>
</html>
